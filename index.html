<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Perlin Underground — Full Res Smooth</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/addons/p5.dom.min.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #0b1020;
        color: #e6f0ff;
        font-family: sans-serif;
      }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.6);
        padding: 8px;
        border-radius: 6px;
        z-index: 10;
      }
      button,
      input {
        margin: 2px;
      }
      #log {
        max-height: 100px;
        overflow-y: auto;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <button id="simulateBtn">Simulate</button>
      <div>
        <input id="manualInput" placeholder="Type UP/DOWN/LEFT/RIGHT" />
        <button id="sendManual">Send</button>
      </div>
      <div id="status">Status: disconnected</div>
      <div id="lastCmd">Last: —</div>
      <div id="log"></div>
    </div>

    <script id="vert" type="x-shader/x-vertex">
      attribute vec3 aPosition;
      varying vec2 vPos;
      void main() {
        vPos = aPosition.xy;
        gl_Position = vec4(aPosition, 1.0);
      }
    </script>
    <script id="frag" type="x-shader/x-fragment">
      precision highp float;
      varying vec2 vPos;
      uniform float uOffsetX;
      uniform float uOffsetY;
      uniform float uNoiseScale;
      // Simple Perlin noise implementation (or use p5's noise GLSL)
      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
      }
      float noise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        float a = hash(i);
        float b = hash(i + vec2(1.0, 0.0));
        float c = hash(i + vec2(0.0, 1.0));
        float d = hash(i + vec2(1.0, 1.0));
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }
      void main() {
        vec2 uv = gl_FragCoord.xy;
        float n = noise((uv + vec2(uOffsetX, uOffsetY)) * uNoiseScale);
        float col = n > 0.55 ? 0.2 : 0.8;
        gl_FragColor = vec4(vec3(col), 1.0);
      }
    </script>
    <script>
      let port,
        reader,
        keepReading = false;
      let offsetX = 0,
        offsetY = 0,
        targetOffsetX = 0,
        targetOffsetY = 0,
        panStep = 40;
      let zoom = 1;
      let noiseScale = 0.006;
      function log(msg) {
        const el = document.createElement("div");
        el.textContent = msg;
        document.getElementById("log").prepend(el);
      }
      async function connectSerial() {
        try {
          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });
          document.getElementById("status").textContent = "Status: connected";
          document.getElementById("connectBtn").disabled = true;
          document.getElementById("disconnectBtn").disabled = false;
          startReadingLoop();
        } catch (e) {
          log("Failed to connect: " + e);
        }
      }
      async function disconnectSerial() {
        keepReading = false;
        if (reader) {
          try {
            await reader.cancel();
          } catch (e) {}
          reader = null;
        }
        if (port) {
          try {
            await port.close();
          } catch (e) {}
          port = null;
        }
        document.getElementById("status").textContent = "Status: disconnected";
        document.getElementById("connectBtn").disabled = false;
        document.getElementById("disconnectBtn").disabled = true;
      }
      async function startReadingLoop() {
        keepReading = true;
        const textDecoder = new TextDecoderStream();
        port.readable.pipeTo(textDecoder.writable);
        reader = textDecoder.readable.getReader();
        let buffer = "";
        while (keepReading) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            buffer += value;
            let lines = buffer.split(/\r?\n/);
            buffer = lines.pop();
            for (const line of lines) handleCommand(line.trim());
          }
        }
      }
      function handleCommand(cmd) {
        if (!cmd) return;
        cmd = cmd.toUpperCase();
        log("RX: " + cmd);
        document.getElementById("lastCmd").textContent = "Last: " + cmd;
        if (cmd === "UP") targetOffsetY += panStep;
        else if (cmd === "DOWN") targetOffsetY -= panStep;
        else if (cmd === "LEFT") targetOffsetX -= panStep;
        else if (cmd === "RIGHT") targetOffsetX += panStep;
        else if (cmd === "LIFT") zoom *= 1.1;
        else if (cmd === "FALL") zoom /= 1.1;
        zoom = Math.max(0.2, Math.min(zoom, 5));
      }
      document.getElementById("connectBtn").onclick = connectSerial;
      document.getElementById("disconnectBtn").onclick = disconnectSerial;
      document.getElementById("simulateBtn").onclick = () => {
        const cmds = ["UP", "DOWN", "LEFT", "RIGHT"];
        handleCommand(cmds[Math.floor(Math.random() * 4)]);
      };
      document.getElementById("sendManual").onclick = () => {
        let val = document.getElementById("manualInput").value.trim();
        if (val) handleCommand(val);
        document.getElementById("manualInput").value = "";
      };
      let terrainShader;
      let sketch = (p) => {
        p.preload = function () {
          // No shader creation here
        };
        p.setup = function () {
          p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
          terrainShader = p.createShader(
            document.getElementById("vert").textContent,
            document.getElementById("frag").textContent
          );
          p.noStroke();
        };
        p.draw = function () {
          // Smoothly interpolate offsetX/Y toward targetOffsetX/Y
          offsetX += (targetOffsetX - offsetX) * 0.15;
          offsetY += (targetOffsetY - offsetY) * 0.15;
          p.background(10, 15, 30);
          terrainShader.setUniform("uOffsetX", offsetX);
          terrainShader.setUniform("uOffsetY", offsetY);
          terrainShader.setUniform("uNoiseScale", noiseScale * zoom);
          p.shader(terrainShader);
          p.rect(-p.width / 2, -p.height / 2, p.width, p.height);
          p.resetShader();
          p.fill(255);
          p.textSize(12);
          p.text(
            `OffsetX: ${offsetX.toFixed(1)} OffsetY: ${offsetY.toFixed(
              1
            )} Zoom: ${zoom.toFixed(2)}`,
            -p.width / 2 + 10,
            -p.height / 2 + 15
          );
        };
        p.windowResized = function () {
          p.resizeCanvas(p.windowWidth, p.windowHeight);
        };
      };
      window._pInst = new p5(sketch);
    </script>
  </body>
</html>
